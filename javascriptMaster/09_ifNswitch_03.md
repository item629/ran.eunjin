## 연상 배열의 요소를 순서대로 처리하기 - for...in 명령
지금까지 소개한 `for`, `while`/`do...while` 명령과는 약간 종류가 다른 반복 명령이 `for...in` 명령이다. `for...in` 명령은 지정된 연상 배열(객체)의 요소를 추출하여 선두부터 순서대로 처리한다.

```javascript
for ( 가변수 in 연상 배열 ) {
	루프 내에서 실행하는 명령(군)
}
```

가변수는 연상 배열(객체)의 키를 일시적으로 보관하기 위한 변수다. 여기에서 가변수에 보관된 것이 요솟값 그 자체가 아님을 주의해야 한다.

<br/>

**for...in 명령의 동작**
>예를 들어 다음은 연상 배열로부터 요솟값을 순서대로 표시하는 예다.

```javascript
var data - { apple:150, orange:100, banana:120 };
for ( var key in data ) {
	console.log(key + '=' + data[key]);
}

-console-
apple=150
orange=100
banana=120
```

<br/><br/>
###배열에서 for...in 명령은 이용하지 않는다.
---
구문상 배열에서도 `for...in` 명령을 이용하는 것은 가능하다. 

```javascript
var data = [ 'apple', 'orange', 'banana' ];
for ( var key in data ) {
	console.log(data[key]);
} // 결과 : 'apple''orange''banana'를 순서대로 출력
```

<br/>
배열의 내용이 순서대로 출력되어 그냥 보기에는 올바른 동작으로 보인다. 그러나 다음과 같은 코드에서는 어떨까?

```javascript
var data = [ 'apple', 'orange', 'banana' ];
// 배열 객체에 hoge 메소드를 추가
Array.prototype.hoge = function () {} // 1
for ( var key in data ) {
	console.log(data[key]);
} // 결과 : 'apple''orange''banana''function () {}'를 순서대로 출력
```

아직 코드의 자세한 의미는 잘 몰라도 상관없다. 일단 *1* 에서 배열의 기능을 확장시키고 있다는 것만 이해해두길 바란다. 그리고 이로 인해 확장된 기능까지 열거되어 버린다(여기에서는 `function () {}`). 또한 아래와 같은 문제도 있다.

- `for...in` 명령에서는 처리의 순서를 보증하지 않는다.
- 가변수에는 인덱스 번호가 보관될 뿐이므로 코드가 그다지 심플하지 않다(=값 그 자체가 아니므로 오히려 오해를 불러 일으킴).

이러한 이유로 `for..in` 명령은 연상 배열(객채)을 조작할 경우에 한하며, 배열의 조회에는 for명령이나 다음 절에 나올 `for...of` 명령을 이용하도록 하자.

<br/>

```javascript
var data = [ 'apple', 'orange', 'banana' ];
for ( var i = 0, len = data.length; i < len; i++ ) {
	console.log(data[i]);
} // 결과 : 'apple''orange''banana'를 순서대로 출력
```

>이곳의 주제와는 벗어나지만 초기화 식에서 배열의 사이즈(data.length)를 취득하고 있다는 점에 주목해보자. <br/>
>두번째 줄의 코드는 다음과 같이 작성해도 동작한다.

<br/>

```javascript
for ( var i = 0; i < data.length; i++ ) {...}
```

>그러나 루프할 때마다 프로퍼티에 접근해야 하므로 성능은 떨어진다. 대상이 배열이 아니라 NodeList 객체인 경우나 현재는 거의 존재하지 않는 Internet Explorer7 브라우저인 경우에는 그 영향이 뚜렷하게 드러난다.


<br/><br/>

## 배열 등을 순서대로 처리하기 - for...of 명령
배열 등을 순서대로 열거하기 위한 또 하나의 수단으로, ES2015에서 추가된 `for...of` 명령이 있다. '배열 등'이라는 표현을 썼는데, 이렇게 표현한 이유는 `for...of` 명령에서는 배열뿐만 아니라 Array와 같은 객체(NodeList, arguments 등), 반복자/생성자 등도 처리할 수 있기 때문이다. 이를 모두 통틀어서 **열거 가능한 객체** 라고도 부른다.

```javascript
for ( 가변수 of 열거 가능한 객체 ) {
	루프 내에서 실행하는 명령(군)
}
```
구문은 `for..in` 명령과 거의 같으므로 곧바로 구체적인 예를 살펴보자.
<br/>

```javascript
var data = [ 'apple', 'orange', 'banana' ];
Array.prototype.hoge = function () {}
for ( var value of data ) {
	console.log(value);
} // 결과 : 'apple''orange''banana'를 순서대로 출력
```

확실히 배열 data의 내용이 올바로 출력되어 있음을 확인할 수 있다.<br/>
또한 `for...in` 명령에서는 가변수에 키명(인덱스 변호)이 건네진 것에 반해, `for...of`명령에서는 값을 열거하고 있다는 점이 주목할 만한 부분이다.

<br/><br/>
## 루프를 도중에 스킵/중단하기 - break/continue 명령
일반적으로 `while`/`do...while`, `for...in` 명령은 미리 정해진 종료 조건을 만족하는 타이밍에 루프를 종료하지만, '특정 조건을 만족하는 경우에 루프를 강제적으로 둥간하고 싶은'경우도 있다. 이럴 때 이용할 수 있는 것이 앞서 `switch` 명령에서 등장한 `break` 명령이다.
<br/>

```javascript
var result = 0;
for ( var i = 1; 1 <= 100; i++ ) {
	result += i;
	if ( result > 1000 ) { break; }
}
console.log('합계값이 1000을 넘은 것은 ' + i); // 결과 : 합계값이 1000을 넘은 것은 45
```

여기에서는 변수 i를 1 ~ 100 사이에서 더해나가 합계(변수 result)가 1000을 넘을 때 루프를 빠져나오고 있다. 이렇듯 `break` 명령은 `if` 명령과 함께 사용하는 것이 일반적이다.


<Br/><br/>
한편 루프를 완전히 중단해버리는 것이 아니라, '현재의 루프만을 건너뛰고 다음 루프를 계속해서 실행하고 싶은' 경우에는 `continue` 명령을 사용한다. 아래의 코드는 변수 i를 1~100 사이에서 홀수만 더해 그 합계를 구하는 예제다.

```javascript
var result = 0;
for ( var i = 1; i < 100; i++ ) {
	if ( i % 2 === 0 ) { continue; }
	result += i;
}
console.log('합계:' + result); // 결과: 합계:2500
```

여기에서는 카운터 변수 i가 짝수(변수 i가 2로 완전히 나누어짐)인 경우에만 처리를 건너뜀으로써 홀수만의 합계를 구하고 있다.

<br/><br/>

### 중첩된 루프 한 번에 빠져 나오기 - 레이블 구문
---
중첩된 루프 안에서 `break` 또는 `continue` 명령을 사용할 경우, 디폴트로 가장 안쪽의 루프를 탈출하거나 스킵(skip)한다.

```javascript
for ( var i = 1; i < 10; i++ ) {
	for ( var j = 1; j <10; j++ ) {
		var k = i * j;
		if( k > 30 ) { break; }
		document.write(k + '&nbsp');
	}
	document.write('<br/>');
}
```

![Open in browser](./img/label1.png)

>여기서는 변수 K(카운터 변수 i, j의 곱셈값)가 30이 넘는 경우에 break 명령을 실행하고 있다. 이로 인해 안쪽 루프만을 빠져 나오고 있으므로 결과적으로 '곱셈값이 30 이하의 값만을 표시하는 구구단'을 생성하게 된 것이다.

<br/><br/>

**document.write 보다 testContext/InnerHTML을 우선한다**
>document.write는 페이지에 지정된 문자열을 출력하기 위한 명령이다. 이전의 Javascript에서는 자주 사용되던 메소드였다. 하지만 '도큐먼트를 모두 출력한 후에 호출하는 경우에는 페이지가 일단 클리어되어버린다'는 등 약간 특수한 동작을 지닌 메소드다. 여기에서는 단순화하기 위해서 일부러 이용하고 있지만, 실제 애플리케이션에서는 textContext/InnerHTML 등의 명령을 우선해서 이용하길 바란다.

이것을 '한 번 곱셈값이 30을 넘으면, 구구단 출력 자체를 정지시키도록' 만들고 싶다면, 어떻게 하면 좋을까.

```javascript
kuku:
for ( var i = 1; i < 10; i++ ) {
	for ( var j = 1; j < 10; j++ ) {
		var k = i * j
		if ( k > 30 ) { break kuku; }
		document.write(k + '&nbsp');
	}
	document.write('<br/>');
}
```

![Open in browser](./img/label2.png)

이렇게 빠져 나오고자 하는 루프의 선두에 레이블을 지정하면 된다. 레이블은 아래와 같은 형식으로 지정한다.

`레이블명: `

레이블명은 임의로 부여할 수 있다. 그 다음에는 `break`/`continue` 명령에도 아래와 같이 레이블을 지정함으로써, 이번에는 (안쪽의 루프가 아닌) 레이블이 부여된 루프를 탈출할 수 있다.

`break 레이블명;`

<br/>

**루프 안의 switch 명령**
> 루프 안에서 switch 명령을 이용하는 경우 주의가 필요하다. switch 명령 안에서 break 명령을 이용한다해도 그것은 'switch 명령을 빠져 나온다'라는 의미만을 갖고 있기 때문이다. switch 명령을 감싸고 있는 루프로부터 빠져 나오기 위해서는 레이블 구문을 이용해야만 한다.


<br/><br/>

## 예외 처리하기 - try...catch...finally 명령
>애플리케이션을 실행하다 보면 '숫자를 취할 것이라고 생각했던 함수에 문자열이 건네진 경우', '변수를 참조하려고 했으나 미정의였던 경우'등 프로그래밍 시에는 생각하지 못했던 여러 가지 오류(예외)가 발생하곤 한다.<br/>
물론 예외의 종류에 따라 프로그래밍을 할 때 미연에 방지할 수 있는 것도 있지만, '인수에 예기치 못한 값이 건네졌다', '함수나 클래스가 의도하지 않은 방법으로 사용되었다' 등 외부 요인에 의존하는 처리인 경우에는 예외의 발생을 완전히 막을 수 없다.<br/>
그러한 경우에도 스크립트 전체가 정지해버리는 일이 없도록 하는 것이 예외 처리의 역할이다. 이 예외 처리를 실현하는 명령이 `try...catch...finally` 명령이다.

```javascript
try {
	예외가 발생할지 모를 명령(군)
} catch (예외정보를 취할 변수) {
	예외가 발생했을 시의 명령(군)
} finally {
	예외의 유무에 관계없이 최종적으로 실행되는 명령(군)
}
```

<br/><br/>

구체적인 코드를 살펴보자.

```javascript
var i = 1;
try{
	i = i * j; // 1: 예외 발생
} catch(e) {
	console.log(e.message);
} finally {
	console.log('처리가 완료되었다.');
}

-console-
j is not defined
처리가 완료되었다.
```

> 만일 `try...catch...finally` 명령을 이용하지 않았다면 *1* 의 시점에서 예외(미정의 변수를 참조하려 했기 때문)가 발생하여 스크립트가 정지되었을 것이 틀림없다. 그러나 `try` 블록에서 예외가 발생했을 경우, 처리는 그래도 `catch` 블록에 인도되어 후속의 *2* 도 제대로 처리되는 것을 확인할 수 있을 것이다. <br/>
finally 블록은 불필요한 경우에 생략해도 상관없다.

<br/>

참고로, 에러 정보는 catch 블록의 Error 객체로(여기에서는 변수 e) 인도된다. 여기서는 Error 객체에 준비되어 있는 message 프로퍼티를 사용하여 에러 메세지를 표시하고 있을 뿐이지만, 그 외의 블록과 동일하게 필요에 따라서 임의의 처리를 기술할 수 있다.

![Open in browser](./img/trycatch.png)

<br/>

**예외 처리는 오버헤드가 크다**
> 예외 처리는 확실하게 동작하는 스크립트를 기술하는 데 있어 없어서는 안 되는 방식이지만, 오버헤드가 큰 처리기도 하다. 예를 들어, 루프 처리 안에서 `try...catch` 블록을 기술하는 것은 피해야 한다. 일단 '`try...catch` 블록을 루프의 바깥쪽에 배치할 수 없을까'를 검토하길 바란다.

<br/>

예외는 프로그램 안에서 발생한 것을 처리할 뿐만 아니라, 자신이 직접 발생시키는 것도 가능하다. 

```javascript
var x = 1;
var y = 0;
try{
	if( y === 0 ) { throw ner Error('0으로 나누려고 하였다.'); } // 1
	var z = x / y;
} catch(e) {
	console.log(e.message);
} // 2

-console-
0으로 나누려고 하였다.
```
예외를 발생시키려는 것은 `throw` 명령의 역할이다(1). 예외를 발생시키는 것을 '예외를 throw한다'고도 한다.

**(구문)throw 명령**

`throw new Error(에러 메세지)`

<br/>

여기에서는 `변수 y가 0인 경우에 Error 객체를 생성하여 처리를 catch 블록으로 이동하도록` 하고 있다. 이렇게 `throw` 명령은 대부분의 경우, `if` 명령과 같은 조건 분기 명령과 함께 사용한다.<br/>
예외의 원인에 따라 `Error 객체` 대신 다음의 `XxxxxError 객체`를 이용하는 것도 가능하다.

|객체|에러의 원인|
|:---:|:---:|
| EvalError | 부정한 eval 함수 |
| RangeError | 지정된 값이 허용 범위를 넘었다 |
| ReferenceError | 선언되어 있지 않은 변수에 접근했다 |
| SyntaxError | 문법 에러 |
| TypeError | 지정된 값이 기대한 데이터형이 아니다 |
| URIError | 부정한 URI |

`catch` 블록에는 앞에서와 동일하게 `throw`된 `Error 객체`로부터 `message` 프로퍼티를 취득하여 이것을 로그로 출력하고 있다(2).

<br/>

아마도 지금의 단계라면 예외 처리를 이용해야 하는 이유를 이해하기 어려울 수도 있겠다. 그러나 자기 자신이 처리에 관련된 모든 값을 결정하고 있는 상황이라면, 값의 부정합에 의한 버그는 프로그램을 실행하기 전에 미리 해소해두는 것이 좋다.

<br/><br/>

## Javascript의 위험한 구문 금지하기
>오랜 역사를 가진 `Javascript`에는 '사양으로는 존재하지만 현재는 안전성과 효율성 면에서 사용하지 말아야 할 구문'이 존재한다. 이전에는 이러한 구문의 함정을 개발자가 배워서 함정을 피하도록 코딩해야 했다.<br/>
그러나 이것은 개발자에 불필요한 부담을 주는 것이다. 게다가 애초부터 개발자의 수준에 따라 좋지 않은 코드가 들어오는 것을 완전히 막는 것은 불가능하다. 그러한 이유로 Javascript의 함정을 발견하여 오류로 통지해주는 구조가 도입되었는데, 이것이 바로 `strict` 모드다.<br/>

**Strict 모드** 로 통지 대상이 되는 주요 구문을 아래에 정리해두었다.

| 분류 | Strict 모드에 의한 제한 |
|:----:|:----:|
|변수 |var 명령의 생략 금지<br/>나중에 추가 예정인 키워드를 예약어로 추가<br/>인수/프로퍼티명의 중복 금지<br/>undefined/null로의 대입 금지|
|명령|with 명령의 이용 금지<br/>arguments.callee 프로퍼티로의 액세스 금지<br/>eval 명령으로 선언된 변수를 주위의 스코프로 확산하지 않기 |
| 그 외 | 함수 안의 this는 글로벌 객체를 참조하지 않는다(undefined가 됨)<br/>'0~'의 8진수 표기법은 금지

`strict 모드`를 사용하면 `Javascript`의 함정을 미연에 막을 수 있을 뿐만 아니라 다음과 같은 장점도 있다.

- 비 Strict 모드의 코드보다도 빠르게 동작하는 경우가 있음
- 미래의 Javascript에서 변경되는 점을 금지함으로써 향후 이행이 간단하게 됨
- Javascript의 '하지 말아야 할 것'을 이해하는 단서가 됨

<Br/><br/>

### Strict 모드를 활성화하기
---
`Strict 모드`를 활성화하려면 스크립트의 선두나 함수의 본체 선두 부분에 `'use strict';`이라는 문장을 추가하면 된다.

```javascript
'use strict';
//임의의 코드 1

function hoge() {
'use strict';
//함수의 본체 2
}
```

*1* 에서는 이후의 전체 스크립트가 `Strict 모드`로 해석되고, *2* 에서는 함수의 스크립트가 `Strict 모드`로 해석되게 된다. 단, *1* 의 경우는 여러 스크립트를 연결한 경우 이후의 모든 코드에 영향을 미친다. 그때 하나라도 `비 Strict 모드`의 코드가 혼재되는 경우에는 제대로 동작하지 않을 수 있다. 일반적으로는 유효 범위를 한정할 수 있는 *2* 의 표기법이 바람직하다. 일반적으로 즉시 함수의 관용구를 이용하면 자연스럽고 적절하게 코드 전체에 `Strict 모드`를 적용할 수 있다.

<br/>

**Strict 모드 지원 브라우저**
>Strict 모드는 Internet Explorer에서는 버전 10 이상에서만 지원하다는 점에 주의해야 한다.<br/>
>단 `'use strict';`는 무해한 문자열식이기 때문에 Strict 모드를 지원하지 않는 브라우저에서는 무시될 뿐이다.<br/>
>그러므로 본문에서 언급했듯이 새로운 개발은 가능한 Strict 모드를 사용할 것을 추천한다.

<br/>

**외부 스크립트를 비동기방식으로 로드하기 - async/defer 속성 -**
> 일반 브라우저에서는 스크립트의 읽기 및 실행이 왼료될 때까지 뒤에 있는 컨텐츠를 렌더링하지 않는다. 웹 페이지의 앞 부분에 사이즈가 큰 스크립트가 있다면 그로 인해 아무것도 표시되지 않는 시간이 길어질 수 있다.<br/>
> 이러한 현상을 피하기 위해 `</body>` 태그 바로 앞에 `<script>` 요소를 배치하는 방법을 소개하였다. 이에 따라 표시하고자 했던 콘텐츠를 먼저 표시한 후 뒤에서는 조용히 스크립트를 읽어 들임으로써 사용자의 체감 속도를 향상시킬 수 있게 된다.<br/>
> 참고로 이 일반 브라우저를 대상으로 하고 있다면, HTML5에 새롭게 추가된 async 속성을 이용하는 것도 가능하다.
> 
> ```javascript
> <script src="app.js" async></script>
> ```
>  이에 따라 src 속성에 지정된 스크립트를 비동기 방식으로 로드하는 것이 가능하며, 로드가 완료되는 대로 순차적으로 실행하게 된다. <br/>
> 단, async 속성이 있는 `<script>` 요소는 그 특성상 실행 순서가 보장되지 않는다는 점에 주의해야 한다. 예를 들어 다음과 같은 코드에서 app.js가 lib.js에 의존한다고 가정해보자. 이 코드의 경우, 어느 쪽이 먼저 실행되는지 알 수 없다. 같은 이유로 실행 순서에 따라 app.js가 제대로 작동하지 않을 가능성도 있다.
> 
> ```javascript
> <script src="lib.js" async></script>
> <script src="app.js" async></script>
> ```
> 이런 경우에는 의존 관계인 .js 파일을 미리 하나로 통합하거나 async 속성 대신 defer 속성을 지정하는 것이 좋다. defer 속성은 문서 해석을 종료할 때까지 스크립트의 실행을 지연시키도록 지시하는 속성이다.


