
# 연산자 02

좌변/우변의 값을 비교하여 그 결과를 true/false로 반환한다.

* 주요 비교 연산자

|연산자|개요|
|--------|--------|
| == | 좌변과 우변의 값이 같을 경우, true |
| != | 좌변과 우변의 값이 같지 않을 경우, true |
| < | 좌변이 우변보다 작은 경우, true |
| <= | 좌변이 우변보다 작거나 같을 경우, true |
| > | 좌변이 우변보다 클 경우, true |
| >= | 좌변이 우변보다 크거나 같을 경우, true |
| === | 좌변과 우변의 값이 같고 데이터형도 같을 경우, true |
| !== | 좌변과 우변의 값이 같지 않을 경우 또는 데이터형이 다른 경우, true |
| ?: |'조건식? 식1:식2' 조건식이 true인 경우는 식1을, false인 경우는 식2를 취한다. |


비교 연산자도 산술 연산자와 동일하게 바로 이해하기 쉬운 것이 대부분이지만 몇 가지 주의해야 할 점이 있다.

<br/><br/>

## 등가 연산자(==)
'=='연산자는 좌변/우변의 값을 비교하여 **같은 경우는 true** , **같지 않은 경우는 false** 를 반환한다. 그러나 아래와 같이 오퍼랜드의 데이터형에 따라 비교의 기준이 다르므로 주의가 필요하다.

- 등가 연산자의 평가 기준

~~~
좌변과 우변의 형이 동일할 때

문자열/수치/논리형 : 단순히 쌍방의 갑싱 동일한지를 판단
배열/객체 : 참조 장소가 동일한지를 판단
null/undifined : 쌍방이 모두 null/undifined, 또는 null과 undefined의 비교는 모두 true

좌변과 우변의 형이 다를 때

문자열/수치/논리형 : 문자열/논리형을 수치로 변환한 후에 판단
객체 : 기본형으로 변환한 후에 판단
~~~ 

이렇게 보면 복잡하게 느껴질지도 모르겠지만, 등가 연산자는 "오퍼랜드의 데이터령이 다른 경우에도 데이터형을 변환하여 '어떻게든 같다고 보여야겠다'고 시도하는" 연산자라고 생각할 수 있다. 그러므로 예를 들어 다음과 같은 수치형과 논리형의 비교는 등가 연산자에서 true로 인지된다.

~~~
console.log( 1 == true ); // 결과 : true
~~~

다만, 비교의 대상이 배열이나 객체 등 이른바 참조형인 경우에는 주의가 필요하다. 이래의 코드를 보자.

~~~
var data1 = ['Javascript', 'Ajax', 'ASP.NET'];
var data2 = ['Javascript', 'Ajax', 'ASP.NET'];
console.log(data1 == data2); // 결과 : false
~~~

기본형은 변수에 값을 직접 보관하는 반면, 참조형에서는 그 참조값(메모리상의 주소)을 보관하였다. 그리고 등가 연산자에서 참조형을 비교하는 경우에는 참조값 - 메모리상의 어드레스가 동일한 경우에만 true가 반환된다. 보기에는 동일한 내용을 포함하고 있는 객체라고 해도 그것이 다른 객체(다른 어드레스로 등록된 것)라면 등가 연산자는 false를 반환한다.

* 기본형에서는 : 값 그 자체를 비교하므로 보이는 것과 비교 결과가 일치
* 참조형에서는 : 값을 보관하고 있는 참조 장소를 비교하므로 보이는 것과 비교 결과가 서로 일치하지 않는 경우가 있다.
<br/><br/>

### 등가 연산자(==)와 동치 연산자(===)
---
다시 한번 말하지만, '==' 연산자는 오퍼랜드가 '어떻게든 같다고 볼 수 없을까'라고 Javascript가 이리 저리 노력해주는 (친절한) 연산자다. 이것으로 인해 개발자는 그다지 데이터형을 의식하지 않고 코딩할 수 있다.<br/>
단, 이 친절함이 때로는 방해가 되는 경우도 있다. 예를 들어 다음과 같은 경우는 어느 쪽이든 ture로 판정해버린다.

~~~
console.log('3.14E2' == 314);
console.log('0x10' == 16);
console.log('1' == 1);
~~~

3.14E2는 지수 표현, 0x10은 16진수 표현으로 해석되어 버린다. E, x가 의미를 가지지 않은 단순한 알파벳임에도 '=='연산자는 그렇게 해석하지 않는다.<br/>
이러한 경우에 사용하는 것이 '==='연산자다. '==='는 데이터형을 변환하지 않는다는 점을 빼고는 '=='연산자와 동일 규칙으로 오퍼랜드를 비교한다.

~~~
console.log('3.14E2' === 314);
console.log('0x10' === 16);
console.log('1' === 1);
~~~

이번에는 모든 결과가 false다. 단, '===' 연산자에서는 '1'과 1처럼 그냥 보기에 동일한 값으로 보이는 리터럴도 서로 다른 것으로 인지해버리므로 주의가 필요하다. 문자열로서의 '1'과 숫자로서의 1은 '==='연산자에서는 서로 다른 것이다. 

<br/><br/>

## 조건 연산자

조건 연산자는 이름 그대로 지정된 조건식의 진위에 따라서 대응하는 식의 값을 서로 다르게 출력하고 싶은 경우에 사용한다. 이는 3항 연산자라고 불리기도 한다. if 명령을 사용해도 동등한 처리를 표현할 수 있지만, '단순히 출력할 값을 조건에 따라 배분하고 싶은 경우'라면 조건 연산자를 이용하여 더욱 간단하게 코드를 기술할 수 있다. 

~~~
var x = 80;
console.log(x >= 70) ? '합격' : '불합격'); // 결과 : 합격
~~~

<br/><br/>

## 논리 연산자

복수의 조건식(또는 논리값)을 논리적으로 결합하여 그 결과를 true/false값으로 반환한다. 일반적으로 앞 절의 비교 연산자와 조합해서 사용하면 더 복잡한 조건식을 표현할 수 있다.

<br/>
* 주요 논리 연산자

~~~
&& : 좌우식이 모두 true인 경우, true
|| : 좌우식의 어느 쪼ㅓㄱ이든 true인 경우, true
! : 식이 false인 경우,true
~~~

<br/>

~~~
var x = 1;
var y = 2;
console.log(x === 1 && y === 1); // 결과 : false
console.log(x === 1 || y === 1); // 결과 : true
~~~

<br/>

논리 연산자의 평가 결과는 좌측식/우측식의 논리값에 따라 달라진다. 좌측식/우측식의 값과 구체적인 결과의 대응 관계는 다음 표와 같다.

~~~
true/ture : &&/true , ||/true
true/false : &&/false, ||/true
false/true : &&/false, ||/true
flase/false : &&/false, ||/false
~~~

참고로 Javascript에서는 아래의 값도 암묵적으로 flase로 인정된다(이것을 false와 같은 값이라고 부르는 경우도 있다.). 논리 연산자의 오퍼랜드가 반드시 논리형의 true/false일 필요는 없다는 점에 주의하자.
- 빈 문자열("")
- 숫자0, NaN(Not a Number)
- null, undefined

상기의 값 이외는 모두 true로 인식된다.

<br/><br/>

## 논리 AND 연산자(&&)와 논리 OR 연산자(||)

논리 AND/OR 연산자를 이용하는 경우, '좌측식만 판정되고 우측식은 판정되지 않는' 케이스가 있다는 점을 주의하지 않으면 안 된다.
예를 들면 '&&' 연산자의 경우 좌측이 false라고 판정된 시점에 조건식 전체가 반드시 false가 되므로 우측식은 판정(실행)되지 않는다. 이러한 평가를 **단락 회로 평가(Short Circuit Evaluation)** 라고 한다. 

~~~
1: if(x === 1){console.log('안녕하세요');}
2: x === 1 && console.log('안녕하세요');
~~~

*1* 에서는 변수가 1인 경우에 메세지를 표시한다.<br/>
반면, *2* 는 이것을 &&연산자의 특성을 살려서 다시 작성하였다. 앞에서 설명한 것처럼 좌측식이 false인 경우, &&연산자에서는 우측식이 실행되지 않는다. 즉 여기서는 변수 x가 1인 경우에만 우측식의 console.log 명령을 실행한다.<br/>
본래 *2* 와 같은 기술 방법은 원칙상 피해야 한다. 왜냐하면 '조건 분기라는 것이 한눈에 알아보기 어렵'기 때문이다. 또한 '우측식이 실행될지 어떨지 애매한 상황이므로 예상치 못한 버그의 온상이 되기 쉽다'는 이유도 있다.<br/>
기본적으로 **논리 연산자의 뒤쪽에는 함수의 호풀, 증가/감소 연산자, 대입 연산자 등 값을 실제로 조작하려는 식을 포함하면 안 된다.**

<br/>
그리고 이러한 사정은 '||'연산자에서도 동일하다. 연산자에서는 좌측식이 true인 경우, 조건식 전체가 반드시 true가 되므로 우측식은 실행되지 않는다.

<br/><br/>

## 단락 회로 평가의 용도
단락 회로 평가를 사용하는 경우가 있는데, 예를 들면 다음과 같은 경우이다.

~~~
var msg = '';
msg = msg || '안녕하세요, 자바스크립트';
console.log(msg); // 결과 : 안녕하세요, 자바스크립트
~~~

변수 msg가 false와 같은 값 - 빈 문자열 등인 경우에 기본값으로서 '안녕하세요, 자바스크립트'를 대입한다.

* **false와 같은 값에 의미가 있는 경우에는 주의해야 한다.**


~~~
msg = ( msg === undefined ? '안녕하세요, 자바스크립트' : msg);

이것에 의해 변수가 msg가 undefined(미정의)인 경우에만 기본값이 적용된다.
~~~

