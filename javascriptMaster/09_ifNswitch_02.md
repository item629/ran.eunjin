## 식의 값에 따라 분기 처리하기
지금까지의 예를 봐서 알겠지만 if 명령을 이용함으로써 단순한 분기에서 복잡한 다분기까지 유연하게 표현할 수 있다. 하지만 다음의 예에서는 어떨까?

```javascript
var rank = '8';
if ( rank === 'A' ) {
	console.log('A랭크입니다.');
} else if ( rank === 'B' ) {
	console.log('B랭크입니다.');
} else if ( rank === 'C' ) {
	console.log)'C랭크입니다.');
} else {
	console.log('아무 랭크도 아닙니다.');
}
```

`변수 ==- 값`의 형식으로 동일 조건식이 나열되어 있기 때문에 코드 자체가 상당히 장황하게 보인다. 이런 경우에는 **switch** 명령을 이용해야 한다. `switch` 명령은 '동치 연산자에 의한 다중 분기'에 특화된 조건 분기 명령이다. 같은 조건식을 반복해서 기술하지 않아도 되므로 코드가 깔끔하게 정리돼서 읽기 쉽다.

```javascript
switch (식 ) {
 case 값1;
 	'식 = 값1'인 경우에 실행되는 명령(군)
 case 값2:
 	'식 = 값2'인 경우에 실행되는 명령(군)
 
 .
 .
 .
 
 default;
 	식의 값이 모든 값에 조건상 일치하지 않을 경우에 실행되는 명령(군)
 }
```

switch에서는 아래의 순서대로 처리가 실생된다.

1. 선두의 식이 우선 평가된다.
2. 위 1의 값에 일치하는 case 블록을 실행한다.
3. 일치하는 case 블록이 없을 경우에는 ㅏ지막의 default 블록을 호출한다.

`default` 구문은 필수가 아니지만, 어느 case 구문에도 해당하지 않는 경우의 동작을 명확히 처리하기 위해서라도 생략해서는 안 된다.

그럼 switch 명령을 사용한 구체적인 코드를 보도록 하자. 가장 상단에 있는 내용을 switch 명령으로 치환한 것이다.

```javascript
var rank = 'B';
switch(rank) {
	case 'A' :
		console.log('A랭크입니다.');
		break;
	case 'B' :
		console.log('B랭크입니다.');
		break;
	case 'C' :
		console.log('C랭크입니다.');
		break;
	defalut :
		console.log('아무 랭크도 아닙니다.');
		break;
} // 결과 : B랭크입니다.
```

여기서 주목해야 할 것은 '각각의 case 구문과 defalut 구문의 끝에는 반드시 break 명령을 지정하고 있다'는 것이다. break는 현재의 블록으로부터 처리가 빠져 나오기 위한 제어 명령이다.

if 명령과는 다르게 switch 명령은 **조건에 일치하는 case 구문으로 처리를 이동할 뿐, 그 구문을 종료한 후에도 자동적으로 switch 블록을 종료하는 구조가 아니다.**

break 명령을 지정하지 않을 경우, 다음의 case 블록을 계속해서 실행해버려 본래 의도했던 결과를 얻지 못할 수 있다.

<br/><br/>

### 의도한 break 명령의 생략
>의도적으로 break 명령을 생략하여 복수의 블록을 계속 실행하는 **조건 통과(fall through)** 라는 작성 방식도 가능하지만, 코드의 흐름을 이해하기 어렵게 만드는 원인이 될 수 있으므로 일반적으로는 사용을 피해야한다.<br/>
단, 예외로 아래와 같은 케이스에서는 복수의 블록을 (break 명령을 끼워 넣지 않고) 사용해도 무방하다.

```javascript
var rank = 'B';
switch(rank) {
	case 'A' :
	case 'B' :
	case 'C' :
		console.log('합격!');
		break;
	case 'D' :
		console.log('불합격...');
		break;
} // 결과 : 합격;
```

<br/>

### 주의 : switch 식과 case 값은 `===` 연산자로 비교한다
>switch 명령 선두의 식과 case 구문의 식은 (`==` 연산자가 아니라) `===`연산자로 비교한다는 점에서 주의가 필요하다.
예를 들어 다음의 코드에서 `case 0`구문은 실행되지 않는다.

```javascript
var x = '0';
switch (x) {
	case 0 :
		//이 부분은 실행되지 않는다	
		... 중략 ...
}
```

`===` 연산자에서는 문자열로써의 '0'과 숫자 0이 다르기 때문이다. '보이는 값이 같은데도 불구하고 의도한 구문이 호출되지 않는' 경우에는 데이터형의 불일치를 의심해보는 것도 좋을 것이다.

<br/><br/>

## 조건식에 따라 루프 제어하기 - while/do...while 명령
조건 분기 처리처럼 자주 이용되는 것이 반복 처리다. 반복 처리에는 for, for...in, while, do...while 명령 등 몇 가지 비슷한 명령이 존재한다. 개별 구문뿐만 아니라 각각의 차이에 대해서도 이해하도록 하자.

우선 `while`,`do	...while` 명령은 미리 부여된 조건식이 true인 동안은 루프를 반복한다. 구문은 아래와 같다.

(1) `while` 명령

```javascript
while(조건식) {
	조건식이 true일 때 실행되는 명령(군)
}
```

(2) `do...while`	명령

```javascript
do {
	조건식이 true일 때 실행되는 명령(군)
} while ( 조건식 );
```

`do...while` 명령의 끝부분에는 문장의 종료를 나타내는 세미콜론이 필요하다는 점에 주의해야 한다.

각각의 명령을 이용한 코드를 보자.

```javascript
var x = 8;
while( x < 10 ) {
	console.log('x의 값은 ' + x );
	x++;
} // 결과 : 'x의 값은 8'. 'x의 값은 9'를 순서대로 출력
```

```javascript
do {
	console.log('x의 값은 ' + x);
	x++;
} while( x < 10 ); // 결과 : 'x의 값은 8', 'x의 값은 9'를 순서대로 출력
```

>그냥 보면 `while` 명령과 `do...while`이 동일한 동작을 하고 있는 것처럼 보일지도 모르겠다. 
>그러나 변수 x의 초깃값을 10으로 바꿔보면  `do...while` 명령에서는 'x의 값은 10'이라는 메세지가 표시되지만, <br/>
>`while`에서는 아무것도 표시되지 않는다.<br/>
이를 설명하자면 `while` 명령은 루프를 시작할 때 조건식을 판정(**전치 판정**)하는 데 반해, <br/>
`do...while` 명령은 루프의 마지막에 조건식을 판정(**후치 판정**)하기 때문이다.

>이러한 차이는 '루프가 시작되기 전부터 조건식이 false인 경우'에 결과로 나타낸다. 후치 판정에서는 조건의 참/거짓에 상관없이 반드시 한 번은 루프가 처리되지만, 전치 판정에서는 조건에 따라 루프가 한 번도 처리되지 않는 경우도 있다.

<br/><br/>

## 무한 루프
영원히 종료하지 않는 (종료 조건이 true가 되지 않는) 루프를 **무한 루프** 라고 한다.<br/>
무한 루프는 브라우저에 극단적인 부하를 주게 되어 때로는 컴퓨터를 먹통으로 만드는 원인이 된다. 반복 처리를 기술할 경우에는 우선 루프가 정상적으로 종료하는지를 미리 확인하도록 하자.
>**일부러 무한 루프를 만드는 경우도 있다.** <br/>
>프로그래밍 테크닉으로써 의도적으로 무한 루프로 만드는 경우도 있다. 그러나 그러한 경우에도 반드시 루프의 탈출구는 확보해두어야 한다.

<br/><br/>

## 지정 횟수만큼만 루프 처리하기 - for 명령
조건식의 참/거짓에 대응하여 루프를 제어하는 `while/do...while` 명령에 반해, 이미 지정된 횟수 만큼만 반복처리를 실시하는 명령으로 for 명령이 있다.

**for 명령**

```javascript
for ( 초기화 식; 루프 계속 조건식; 증감식 ) {
	루프 내에서 실행하는 명령(군)
}
```

상단의 while 명령을 for 명령으로 다시 작성한 것이다. 변수의 값에 따라 루프를 제어하는 경우에는 콤팩트하게 고드 작성이 가능하다.

```javascript
for ( var x = 8; x < 10; x++ ) {
	console.log('x의 값은 ' + x );
}
```

>우선 for 블록에 들어간 처음 루프에서 **초기화 식** 을 한 번만 실행한다(여기에서는 `var x = 8`). 일반적으로는 이 초기화 식에서 for 명령으로 루프 횟수를 관리하는 **카운터 변수(루프 변수)**를 초기화 한다.<br/>
그 다음, **루프 계속 조건식** 은 블록 내의 처리를 계속하기 위한 조건식을 나타낸다. 이 예에서는 `x < 10`이므로 카운터 변수 x가 10 미만일 동안에만 루프를 반복한다. <br/>
마지막으로 **증감식** 은 블록 내의 처리가 한 번 실행될 때마다 실행된다. 보통은 카운터 변수를 증감하는 증가/감소 연산자 또는 대입 연산자를 지정한다. 여기에서는 `x++`로 하고 있으므로 루프할 때마다 카운터 변수 x에 1이 더해진다. 물론 이 부분을 `x += 2`로 해서 카운터 변수를 2씩 증가하게 하는 것도 가능하며, `x--`로 하나씩 적어지게 하는 것도 가능하다.

<br/>

**for 명령의 동작**

```javascript
(1)
for ( var x = 0; x < 5; x --) { ... }

(2)
for (;;) { ... }
```

예를 들어 *1* 과 같은 for 루프는 카운터 변수 x의 초기값이 0이므로, 그 후 루프할 때마다 감소한다. 그러므로 루프의 계속 조건인 `x<5`가 false가 되는 일은 영원히 없다.<br/>
*2* 는 초기화 식, 루프 계속 조건식, 증감식이 생략된 패턴이다. 이 경우 for 명령은 무조건 루프를 반복한다.

<br/>
**콤마 연산자**

```javascript
/*콤마 연산자를 이용함으로써 초기화 식, 루프 계속 조건식, 증감식에 복수의 식을 지정할 수 있다. 
콤마로 구분된 식은 선두부터 순서대로 실행된다. 예를 들어 다음의 예에서는 초기화 식의 변수 i, j를 각각 
1로 초기화하고, 증감식에서 두 변수를 모두 증가시키고 있다.*/

for ( var i = 1, j = 1; i < 5 ; j ++ ) {
	console.log('i * j는' + 'i * j');
}

-console-
i * j는 1
i * j는 4
i * j는 9
i * j는 16


취향에 따라 다르지만 블록 내이 처리가 매우 단순한 경우에는 콤마 연산자를 이용함으로써 코드를 간단히 표현할 수 있다.

```