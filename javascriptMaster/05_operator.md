# 연산자 01

**연산자(Operator:오퍼레이터)** 란 부여된 변수/리터럴에 대하여 미리 결정된 어떠한 처리를 행하기 위한 기호다. 예를 들어, 지금까지 등장한 (=)나, (.), (-) 등은 모두 연산자다. 또한 연산자에 의해 처리되는 변수/리터럴을 **오퍼랜드(Operand: 피연산자)** 라고 부른다.

```javascript
x = a + b;

=> x, a, b : Operand
=> =, + : Operator
```

<br/><br/>
## 산술 연산자
표준적인 사칙연산을 시작해서 수치와 관련된 연산을 행하는 것이 산술 연산자의 역할이다. **대수 연산자** 라고도 불린다.

- 주요 산술 연산자

| 연산자 | 개요 | 예 |
|--------|--------|--------|
| + | 숫자의 덧셈 | 3 + 5 = 8 |
| - | 숫자의 뺄셈 | 10 - 7 = 3 |
| * | 숫자읙 곱셉 | 3 * 5 = 15 |
| / | 숫자의 나눗셈 | 10 / 5 = 2 |
| % | 숫자의 나머지 연산 | 10 % 4 = 2 |
| ++ | 전치 덧셈 | x = 3; a = ++x; // a는 4 |
| ++ | 후치 덧셈 | x = 3; a = x++; // a는 3 |
| -- | 전치 뺄셈 | x = 3; a = --x; // a는 2 |
| -- | 후치 뺄셈 | x = 3; a = x--; // a는 3

<br/><br/>
### 가산 연산자(+)
> 가산 연산자(+)의 동작은 오퍼랜드의 데이터형에 따라 다르므로 주의가 필요하다.


```javascript
1. console.log(10 + 1); // 결과 : 11
2. console.log('10' + 1); // 결과 : 101
3. var today = new Data();
console.log(1234 + today); // 결과 : 1234Mon Fed 06 2017 21:33:52 GMT+0900 (대한민국 표준시)
```

우선 *1* 과 같이 오퍼랜드가 둘 다 숫자인 경우에는 문제없이 덧셈이 행해진다. 그러나 *2* 와 같이 오퍼랜드의 한쪽이 문자열인 경우에는 어떻게 될까? 문자열이 숫자로 변환되어 *1* 과 같은 결과를 얻을 수 있을 것인가? 아니다. 이 경우에는 '+'연산자가 연결 연산자로 인식되어 101이라는 결과를 낳게 된다.
이것은 *3* 과 같이 오퍼랜드의 한 쪽(양쪽 모두라고)이 객체인 경우에도 동일하다. 이러한 경우는 객체를 문자열 형식(어떠한 형식으로 변환되는지는 객체에 따라 다르다)으로 변환한 다음, 문자열이 연결된다.

<br/><br/>

### 증가 연산자(++)와 감소 연산자(--)
>증가/감소 연산자는 오퍼랜드에 대해서 1을 가산/감산한다.

```
x++ <-> x = x+1
x-- <-> x = x-1
```

단, 증가/감소 연산자에서 연산한 결과를 다른 변수에 대입하는 경우에는 주의가 필요하다.

```javascript
1. var x = 3;
var y = x++;
console.log(x); // 결과 : 4
console.log(y); // 결과 : 3
// 전치 연산 : 먼저 x 값에 1을 더한 후에 y에 대입

2. var x = 3;
var y = ++x;
console.log(x); // 결과 : 4
console.log(y); // 결과 : 4
// 후치 연산 : 먼저 x 값을 y에 대입
```

*1* 에서는 변수 x를 변수 y에 대입한 후 변수 x의 증가를 실시하였다. <br/>
*2* 에서는 변수 x를 증가한 후에 그 결과를 변수 y에 대입하고 있다. 이러한 차이를 이해하지 않으면 예기치 못한 동작에 처할 수도 있으므로 특별히 주의해야한다. 

<br/><br/>
### 소수점을 포함한 계산에는 주의가 필요하다.
---
```javascript
console.log(0.2 * 3); // 결과 : 0.600000000000..
```
<br/>
이것은 Javascript가 내부적으로는 수치 계산을 (10진수가 아닌) 2진수로 행하기 때문에 발생하는 오차다. 이 오차는 극히 작지만, 코드의 내용에 따라서는 생각하지 못한 문제는 불러 일으킨다.
<br/>

```javascript
console.log(0.2 * 3 === 0.6); // 결과 : false
```

소수점을 포함한 연산자에서 엄밀하게 결과를 얻을 필요가 있는 경우나 값의 비교를 행할 경우네는 다음과 같이 하자.

1. 값을 일단 정수로 바꾼 뒤에 연산을 행한다.
2. 위 1의 결과를 다시 소수로 바꾼다.

```javascript
console.log(((0.2 * 10) * 3) / 10); // 결과 : 0.6
console.log((o.2 * 10) * 3 === 0.6 * 10); // 결과 : true
```

<br/><br/>

## 대입 연산자
지정된 변수에 값을 설정(대입)하는 연산자다. 앞서 기술한 '=' 연산자는 대표적인 대입 연산자다. 여기서는 산술 연산자나 비트 연산자와 함게 연동된 기능을 제공하는 복합 대입 연산자도 포함되어 있다.
<br/>

| 연산자 | 개요 | 예 |
|--------|--------|--------|
| `=` | 변수 등에 값을 대입한다. | x = 1 |
| `+=` | 좌변값에 우변값을 더한 값을 대입한다. | x = 3; x += 2 // 5 |
| `-=` | 좌변값에 우변값을 뺀 값을 대입한다. | x = 3; x -= 2 // 1 |
| `*=` | 좌변값에 우변값을 곱한 값을 대입한다. | x = 3; x *= 2 // 6 |
| `/=` | 좌변값에 우변값을 나눈 값을 대입한다. | x = 3; x /= 2 // 1.5 |
| `%=` | 좌변값에 우변값을 나눈 나머지값을 대입한다. | x = 3; x %= 2 // 1 |
| `%=` | 좌변값에 우변값을 비트 AND 연산한 값을 대입한다. | x = 10; x &= 5 // 0 |
| `^=` | 좌변값에 우변값을 비트 XOR 연산한 값을 대입한다. | x = 10; x ^= 5 // 15 |
| `<<=` | 좌변값에 우변값만큼 좌측 시프트한 결과를 대입한다. | x = 10; x <<= 1 // 20 |
| `>>=` | 좌변값에 우변값만큼 우측 시프트한 결과를 대입한다. | x = 10; x >>= 1 // 5 |
| `>>>=` | 좌변값에 우변값만큼 우측 시프트한 결과를 대입한다 (*Unsigned) | x = 10; x >>>= 2 // 2 |

<br/>


<br/><br/>
### 기본형과 참조형에 따른 대입의 차이 - '='연산자
---

```javascript
1.
var x = 1;
var y = x;

x = 2;
console.log(y); // 결과 : 1

2.
var data1 = [0, 1, 2]; // 배열 리터럴을 선언
var data2 = data1;
data1[0] = 5;
console.log(data2); // 결과 : [5, 1, 2]
```
<br/>

우선 *1* 의 결과는 납득하기 쉬울 것이다. 기본형의 값은 변수에도 직접 보관되므로 변수 x의 값을 y에 인도할 경우에도 그 값이 <u>복사된다.</u> (이러한 값의 전달 방법을 값에 의한 전달이라고 한다) 즉 원래 변수 x의 값을 변경해도 복사한 곳의 <u>변수 y에는 영향을 미치지 못한다.</u> <br/>
반면, *2* 의 참조형의 경우에는 좀 복잡하다. 여기에서는 참조형의 예로 배열 리터럴을 변수 data1에 넣어두어 그 내용을 변수 data2에 대입하고 있다. 그러나 참조형의 경우, <u>(값 그 자체가 아닌)값을 보관하고 있는 어드레스가 변수에 보관된다.</u> 즉 'data2 = data1'이라는 것은 변수 data1에 보관되어있는 어드레스를 변수 data2에 대입하고 있는 것에 불과하다. 이러한 값의 전달 방식을 *참조 전달* 이라고 한다. 즉, 이 시점에서 **data1과 data2는 쌍방 모두 같은 값을 보고 있게 되는 것이므로 data1의 변경은 그대로 data2에도 영향을 미친다** 는 뜻이다.

<br/><br/>
### 상수는 '재대입할 수 없다'
---
상수라는 단어를 오해하기 쉬운데, 상수의 제약이란 어디까지나 '다시 대입할 수 없는 변수'이며 반드시 '변경할 수 없다(=읽기 전용)'는 의미는 아니다. 변수에 값을 재대입할 수 없다는 것은 그냥 값을 변경할 수 없다는 의미다.

```javascript
const TAX = 1.08;
TAX = 1.1 ; // 오류
```
<br/>
그런데 참조형에서는 사정이 달라진다.

```javascript
const data = [ 1, 2, 3 ];

1. data = [ 4, 5, 6 ];
2. data[1] = 10;
```

상수라는 어감으로 인해 *1* ,*2* 모두 오류가 되기를 기대해야 하지만 그렇지는 않다. *1* 은 오류가 되지만 *2* 는 그대로 동작한다. 이것이 '재대입이 불가하다'는 의미이다.<br/>
먼저, *1* 은 배열 자체를 재대입하고 있기 때문에 const 명령의 규약 위반이다. 그러나 *2* 는 **원래의 배열은 그대로이고 그 내용만을 고치고 있으므로 이것은 const 위반으로 간주되지 않는다.** 이것이 '상수가 변경할 수 없는 것은 아니다'라고 말한 이유다.

<br/><br/>
### 분할 대입(배열)
---
**분할 대입(destructuring assignment)이란** 배열/객체를 분해하여 안의 요소/프로퍼티값을 개별 변수로 분해하는 구문이다. 예를 들어, 기존 방식이면 배열에서 값을 얻기 위해서 다음과 같이 개별 요소에 엑세스해야 했다.

```javascript
var data = [ 56, 40, 26, 82, 19, 17, 73, 99 ];
var x0 = data[0];
var x1 = data[1];
var x2 = data[2];
...요소의 개수만큼 열거...
```
<br/>
그러나 분할 대입을 이용하여 이를 한 줄로 요약할 수 있다.

```javascript
let data = [ 56, 40, 26, 82, 19, 17, 73, 99 ];
let [ x0, x1, x2, x3, x4, x5, x6, x7 ] = data

console.log(x0); // 결과 : 56
..중간 생략..
console.log(x7); // 결과 : 99
```

이에 따라 오른쪽의 배열이 개별 요소로 분해되어 각각 대응하는 변수 x0, x1...에 대입된다. 대입되는 곳의 변수도 배열과 같이 대괄호([])로 묶여 있는 것이 포인트다.<br/>
`...` 연산자를 이용함으로써 개별 변수로 분해되지 않은 나머지 요소를 정리해서 배열로 잘라내는 것도 가능해진다.

```javscript
let data = [ 56, 40, 26, 82, 19, 17, 73, 99 ];
let [ x0, x1, x2, ...other] = data

console.log(x0); // 결과 : 56
console.log(x1); // 결과 : 40
console.log(x2); // 결과 : 26
console.log(other); // 결과 : [82, 19, 17, 73, 99]
```

<br/>
* 변수의 교환(분할 대입의 이용 예)

```javascript
let x = 1;
let y = 2;
[ x, y ] = [ y, x ];
console.log(x, y); // 결과 : 2, 1
```

<br/><br/>
### 분할 대입(객체)
---
객체의 프로퍼티를 변수로 분해할 수도 있다. 객체의 경우에는 대입할 대상의 변수도 {..}로 감싼다.

```javascript
let book = { title: 'Java포켓 레퍼런스', publish: '기술평론사', price: 26800 };
let { price, title, memo = '없음' } = book;

console.log(title); // 결과 : Jaca포켓 레퍼런스
console.log(price); // 결과 : 26800
console.log(memo); // 결과 : 없음
```

객체의 경우 배열과 달리 이름을 프로퍼티를 개별 변수로 분해한다. 따라서 변수의 순서는 프로퍼티의 정의 순서와 달라도 괜찮으므로 분해하지 않은 프로퍼티(여기에서는 publish)가 있어도 상관없다. 이 경우 왼쪽에 해당하는 변수가 없는 publish 프로퍼티는 무시된다.
또한 원하는 프로퍼티가 존재하지 않는 경우에 대비하여 '변수명 = 디폴트 값'의 형식으로 디폴트값을 지정할 수도 있다. 이 예라면 변수 memo에 대응하는 memo 프로퍼티가 존재하지 않기 때문에 디폴트값으로 '없음'이 적용된다. 
<br/><br/>

#### *중첩된 객체 분해하기
중첩된 객체를 확장하려면 객체의 중첩 관계를 알 수 있도록 대입할 대상의 변수도 `{..}`로 중첩 구조를 나타낸다.

```javascript
ㅣet book = { title : 'Java포켓 레퍼런스', publish: '기술평론사', price: 26800, 
	other : { keywd: 'Java SE 8', logo: 'logo.jpg' } };
let { title, other, other: { keywd } } = book;

console.log(title); // 결과 : Java포켓 레퍼런스
console.log(other); // 결과 : { keywd: 'Java SE 8', logo: 'logo.jpg' }
console.log(keywd); // 결과 : Java SE 8
```

단순히 other로 한 경우에는 other 프로퍼티의 내용(객체)이 함께 저장되고, 'other: {keywd}'로 한 경우에는 other-keywd 프로퍼티의 값이 저장된다.
<br/><br/>

#### *변수의 별명 지정하기
'변수명: 별명'의 형식으로 프로퍼티와는 다른 이름의 변수에 값을 할당할 수도 있다. 다음 예제에서는 title/publish 프로퍼티를 각각 변수 name/company에 대입한다.

```javascript
let book = { title: 'Java포켓 레퍼런스', publish: '기술평론가' };
let { title: name, publish: company } = book;

console.log(name); // 결과 : Java포켓 레퍼런스
console.log(company); // 결과 : 기술평론사
```

<br/>

```javascript
선언이 없는 대입

let price, title, memo; // 변수 선언
({ price,  rirle, memo = '없음'} = book}; // 대입

단, 객체 분할은 전후에 소괄호가 필요하다는 점에 주의해야 한다(배열에서는 불필요). 
왜냐하면 왼쪽의 {...}가 블록으로 간주되어 단독으로는 문장으로 간주되지 않기 때문이다.
```

<br/><br/>